{"ast":null,"code":"// // array in local storage for registered users\n// let users = JSON.parse(localStorage.getItem('users')) || [];\n\n// export function configureFakeBackend() {\n//     let realFetch = window.fetch;\n//     window.fetch = function (url, opts) {\n//         return new Promise((resolve, reject) => {\n//             // wrap in timeout to simulate server api call\n//             setTimeout(() => {\n\n//                 // authenticate\n//                 if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n//                     // get parameters from post request\n//                     let params = JSON.parse(opts.body);\n\n//                     // find if any user matches login credentials\n//                     let filteredUsers = users.filter(user => {\n//                         return user.username === params.username && user.password === params.password;\n//                     });\n\n//                     if (filteredUsers.length) {\n//                         // if login details are valid return user details and fake jwt token\n//                         let user = filteredUsers[0];\n//                         let responseJson = {\n//                             id: user.id,\n//                             username: user.username,\n//                             firstName: user.firstName,\n//                             lastName: user.lastName,\n//                             token: 'fake-jwt-token'\n//                         };\n//                         resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\n//                     } else {\n//                         // else return error\n//                         reject('Username or password is incorrect');\n//                     }\n\n//                     return;\n//                 }\n\n//                 // get users\n//                 if (url.endsWith('/users') && opts.method === 'GET') {\n//                     // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n//                     if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n//                         resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users))});\n//                     } else {\n//                         // return 401 not authorised if token is null or invalid\n//                         reject('Unauthorised');\n//                     }\n\n//                     return;\n//                 }\n\n//                 // get user by id\n//                 if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n//                     // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n//                     if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n//                         // find user by id in users array\n//                         let urlParts = url.split('/');\n//                         let id = parseInt(urlParts[urlParts.length - 1]);\n//                         let matchedUsers = users.filter(user => { return user.id === id; });\n//                         let user = matchedUsers.length ? matchedUsers[0] : null;\n\n//                         // respond 200 OK with user\n//                         resolve({ ok: true, text: () => JSON.stringify(user)});\n//                     } else {\n//                         // return 401 not authorised if token is null or invalid\n//                         reject('Unauthorised');\n//                     }\n\n//                     return;\n//                 }\n\n//                 // register user\n//                 if (url.endsWith('/users/register') && opts.method === 'POST') {\n//                     // get new user object from post body\n//                     let newUser = JSON.parse(opts.body);\n\n//                     // validation\n//                     let duplicateUser = users.filter(user => { return user.username === newUser.username; }).length;\n//                     if (duplicateUser) {\n//                         reject('Username \"' + newUser.username + '\" is already taken');\n//                         return;\n//                     }\n\n//                     // save new user\n//                     newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\n//                     users.push(newUser);\n//                     localStorage.setItem('users', JSON.stringify(users));\n\n//                     // respond 200 OK\n//                     resolve({ ok: true, text: () => Promise.resolve() });\n\n//                     return;\n//                 }\n\n//                 // delete user\n//                 if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\n//                     // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n//                     if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n//                         // find user by id in users array\n//                         let urlParts = url.split('/');\n//                         let id = parseInt(urlParts[urlParts.length - 1]);\n//                         for (let i = 0; i < users.length; i++) {\n//                             let user = users[i];\n//                             if (user.id === id) {\n//                                 // delete user\n//                                 users.splice(i, 1);\n//                                 localStorage.setItem('users', JSON.stringify(users));\n//                                 break;\n//                             }\n//                         }\n\n//                         // respond 200 OK\n//                         resolve({ ok: true, text: () => Promise.resolve() });\n//                     } else {\n//                         // return 401 not authorised if token is null or invalid\n//                         reject('Unauthorised');\n//                     }\n\n//                     return;\n//                 }\n\n//                 // pass through any requests not handled above\n//                 realFetch(url, opts).then(response => resolve(response));\n\n//             }, 500);\n//         });\n//     }\n// }","map":{"version":3,"names":[],"sources":["D:/assessment/react-redux-registration-login-example/src/_helpers/fake-backend.js"],"sourcesContent":["// // array in local storage for registered users\n// let users = JSON.parse(localStorage.getItem('users')) || [];\n    \n// export function configureFakeBackend() {\n//     let realFetch = window.fetch;\n//     window.fetch = function (url, opts) {\n//         return new Promise((resolve, reject) => {\n//             // wrap in timeout to simulate server api call\n//             setTimeout(() => {\n\n//                 // authenticate\n//                 if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n//                     // get parameters from post request\n//                     let params = JSON.parse(opts.body);\n\n//                     // find if any user matches login credentials\n//                     let filteredUsers = users.filter(user => {\n//                         return user.username === params.username && user.password === params.password;\n//                     });\n\n//                     if (filteredUsers.length) {\n//                         // if login details are valid return user details and fake jwt token\n//                         let user = filteredUsers[0];\n//                         let responseJson = {\n//                             id: user.id,\n//                             username: user.username,\n//                             firstName: user.firstName,\n//                             lastName: user.lastName,\n//                             token: 'fake-jwt-token'\n//                         };\n//                         resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\n//                     } else {\n//                         // else return error\n//                         reject('Username or password is incorrect');\n//                     }\n\n//                     return;\n//                 }\n\n//                 // get users\n//                 if (url.endsWith('/users') && opts.method === 'GET') {\n//                     // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n//                     if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n//                         resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users))});\n//                     } else {\n//                         // return 401 not authorised if token is null or invalid\n//                         reject('Unauthorised');\n//                     }\n\n//                     return;\n//                 }\n\n//                 // get user by id\n//                 if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n//                     // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n//                     if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n//                         // find user by id in users array\n//                         let urlParts = url.split('/');\n//                         let id = parseInt(urlParts[urlParts.length - 1]);\n//                         let matchedUsers = users.filter(user => { return user.id === id; });\n//                         let user = matchedUsers.length ? matchedUsers[0] : null;\n\n//                         // respond 200 OK with user\n//                         resolve({ ok: true, text: () => JSON.stringify(user)});\n//                     } else {\n//                         // return 401 not authorised if token is null or invalid\n//                         reject('Unauthorised');\n//                     }\n\n//                     return;\n//                 }\n\n//                 // register user\n//                 if (url.endsWith('/users/register') && opts.method === 'POST') {\n//                     // get new user object from post body\n//                     let newUser = JSON.parse(opts.body);\n\n//                     // validation\n//                     let duplicateUser = users.filter(user => { return user.username === newUser.username; }).length;\n//                     if (duplicateUser) {\n//                         reject('Username \"' + newUser.username + '\" is already taken');\n//                         return;\n//                     }\n\n//                     // save new user\n//                     newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\n//                     users.push(newUser);\n//                     localStorage.setItem('users', JSON.stringify(users));\n\n//                     // respond 200 OK\n//                     resolve({ ok: true, text: () => Promise.resolve() });\n\n//                     return;\n//                 }\n\n//                 // delete user\n//                 if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\n//                     // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n//                     if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n//                         // find user by id in users array\n//                         let urlParts = url.split('/');\n//                         let id = parseInt(urlParts[urlParts.length - 1]);\n//                         for (let i = 0; i < users.length; i++) {\n//                             let user = users[i];\n//                             if (user.id === id) {\n//                                 // delete user\n//                                 users.splice(i, 1);\n//                                 localStorage.setItem('users', JSON.stringify(users));\n//                                 break;\n//                             }\n//                         }\n\n//                         // respond 200 OK\n//                         resolve({ ok: true, text: () => Promise.resolve() });\n//                     } else {\n//                         // return 401 not authorised if token is null or invalid\n//                         reject('Unauthorised');\n//                     }\n\n//                     return;\n//                 }\n\n//                 // pass through any requests not handled above\n//                 realFetch(url, opts).then(response => resolve(response));\n\n//             }, 500);\n//         });\n//     }\n// }"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}